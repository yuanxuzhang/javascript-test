# 函数表达式
定义函数的两种方式：函数声明和函数表达式  
*函数声明提升*（function declareation hoisting）：在执行代码前会先读取声明。函数表达式不具备这种性质。  
*匿名函数*（anonymous function）：function关键字后没有函数标识符，并直接将它赋值给变量。把函数当成值使用的情况下，都可以使用匿名函数。  

## 递归
*递归函数*（recursion function）：一个函数通过名字调用自己，应当包含最终的退出条件。  
**arguments.callee**是一个指向正在执行的函数的指针，可使用它调用函数 __非严格模式下使用__ ，解绑函数名的紧耦合,使得递归程序更健壮。  
## 闭包   
*闭包*（closure）：有权访问**另一个函数**作用域中的**变量**的**函数**。常见方式，在一个函数内部创建另一个函数。  
*执行环境*（execution context）:函数被调用的时候会被创建，定义了变量或函数有权访问的其他数据，决定了它们各自的行为。每个函数都有自己的*执行环境*，当执行流进入一个函数时，函数的环境就会被推入一个*环境栈*中，而在函数执行之后，栈将其环境弹出，该环境将被销毁，保存在其中的变量和函数定义也随之销毁。把控制权返还给之前的执行环境。当代码在一个环境中执行时，会创建变量对象的一个作用域链，并且有一个与之关联的*变量对象*。  
*全局执行环境*：是最外围的一个执行环境，根据ECMAScript实现所在的宿主环境不同，表示执行环境的对象也不一样。Web浏览器中，全局执行环境被认为是Window对象，因此所有全局变量和函数都是作为window对象的属性和方法创建的。  
*作用域链*（scope chain）保证对执行环境有权访问的所有变量和函数的有序访问,作用域链的前端始终是当前执行的代码所在环境的变量对象，*如果这个环境是函数，则将其活动对象作为变量对象*。作用域链中的下一个变量对象来自包含（外部）环境，而再下一个变量对象则来自下一个包含环境，这样一直延续到全局执行环境，全局执行环境的变量对象始终是作用域链中的最后一个对象  。  
*变量对象*（variable object）用于保存*执行环境*中定义的所有变量和函数。  
*活动对象*（activation object）在最开始的时候只包含一个变量，即arguments对象（这个对象在全局环境中是不存在的）。  
*标识符解析* 沿着作用域链一级一级的搜索标识符的过程，从作用域链的前端开始，直到标识符终止。  
__总结__,__创建__ fun函数时，会创建一个预先包含全局变量对象的作用域链，这个作用域链被保存在内部的[[Scope]]属性中。当 __调用__ 函数fun时，会为函数创建一个执行环境，然后通过复制函数[[Scope]]属性中的对象构建起执行环境的作用域链。此后，又有一个活动对象（在此作为变量对象使用）被创建并被推入执行环境作用域链的前端（此时包含了：本地活动对象和全局变量对象）。本质上，作用域链是一个指向变量对象的指针列表，他只引用但不实际包含变量对象。一般来讲，当函数执行完毕后，局部活动对象就会被销毁，内存中仅保存全局作用域（全局执行环境的变量对象）。但是，闭包情况不同：内部函数的作用域链中会包含包含函数的活动对象指针（参考全局活动对象的引用），包含函数执行完后只会销毁器质性环境的作用域链，活动对象不会被销毁，此时还存在内部函数的引用，直到内部函数被销毁之后。 
### 闭包与变量
作用域链机制的副作用：闭包只能取得包含函数中任何变量的最后一个值。闭包函数保存的是整个变量对象，而不是特殊的变量
