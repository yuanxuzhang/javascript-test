## 数组  
- [检测数组](#检测数组)  
- [转换方法](#转换方法)  
- [栈方法](#检测数组)  
- [队列方法 ](#队列方法)  
- [重排序方法](#重排序方法)  
- [操作方法](#操作方法)  
- [位置方法](#位置方法)  
- [迭代方法](#迭代方法)  
- [缩小方法](#缩小方法)

数据的有序列表，特点：  
1. ECMAScript 数组的**每一项**可以保存任何类型的数据。  
2. ECMAScript 数组的大小是可以动态调整的，即可以随着数据的添加自动增长以容纳新增数据。  
创建方式:  
1. `new Array();`。  
2. `new Array(20); // 创建长度为20的数组`。  
3. `new Array("red", "blue", "green"); // 创建一个包含3个字符串值的数组`。  
4. `["red", "blue", "green"]; // 创建一个包含3个字符串的数组 `。  
5. `[1, 2, ]; [ , , ] //创建一个包含2或3项的数组`。  
PS：**使用数组字面量表示法，也不会调用Array构造函数**。  

几点说明：  
1. 如果设置某个值的索引超过了数组现有项数，数组就会自动**增加到该索引值加 1 的长度**。  
2. 数组的项数保存在器 length 属性中，这个属性始终都会返回 0 或更大的值。  
3. 数组的 length 属性不是只读的，因此，通过设置这个属性，可以从数组的尾部移除或向数组中添加新项。  
PS：**如果长度为 1 的数组，设置索引为 99 的那项值，则索引 1 到 98 的返回值将为 undefined**。  
### 检测数组  
方法：  
1. `instanceof Array`，对于一个网页或者一个全局作用域，使用该方式可得到正确的结果。问题在于，它假定单一的全局执行环境，如果网页中包含多个框架（Iframe），那实际上就存在两个以上不同的全局执行环境，从而**存在两个以上不版本的Array构造函数，如果从一个框架向另一个框架传入一个数组，那么传入的数组与第二个框架中原生创建的数组分别具有各自不同的构造函数**。  
2. `Array.isArray()`，ECMAScript5 新增了该方法，这个方法的**目的是最终确定某个值到底是不是数组，而不管它是在哪个全局执行环境中创建的**。
PS：支持的浏览器有：**IE9+**。  

### 转换方法     
1. `toString()`，方法会返回由数组中每个值的字符串形拼接而成的一个以**逗号**分隔的字符串，为了创建这个字符串会调用数组每一项的`toString()`方法。  
2. `valueOf()`，返回的还是数组。  
3. `toLocaleString()`，方时也会创建一个数组值的以逗号分隔的字符串，为了取得每一项的值，这里调用的是每一项的`toLocaleString()`方法。  
4. `join()`,该方法可以使用不同的分隔符来构建字符串。`join()`方法只接受一个参数，即用作分隔符的字符串，然后返回包含所有数组项的字符串，不传值或者传入undefined，则使用逗号作为分隔符。  
[Code]()  
PS：如果数组中的某一项的值时 null 或者 undefined，那么该值在 join()、tolocaleString()、toString() 和 valueOf() 方法返回的结果中以空字符串表示。  
### 栈方法  
ECMAScript 数组提供了一种让数组的行为类似于其他数据结构的方法，即，数组可以表现的就像栈一样 LIFO。  
1. `push()`方法可以接收任意数量的参数，把它们逐个添加到数组**末尾**，并返回修改后数组的长度。  
2. `pop()`方法则从数组**末尾**移除最后一项，减少数组的 length 属性，然后返回移除的项。  
### 队列方法  
ECMAScript 数组可模拟队列数据结构的 FIFO。  
1. `shift()`从数组的**前端**取得项。   
2. `push()`方法是向数组**末端**添加项的方法。  
3. `unshift()`**与 shift 方法的用途相反，它能在数组*前端添加任意个项*并返回新数组的长度，*同时使用 unshift 和 pop方法，可以从相反的方向来模拟队列，即在数组的前端添加项，从数组的末端移除项***。
PS：IE7 及更早版本对 Javascript 的实现中存在一个偏差，其 `unshift()`方法总是返回 undefined 而不是数组的新长度。IE8 在非兼容模式下会返回正确的的长度值。  
### 重排序方法  
数组中已经存在两个可以直接用来重排虚的方法：`reverse() 和 sort()`。  
说明：  
1. sort 不带参数方法按升序排列数组项，排序原理为：调用数组项的 toString 方法转型，然后比较得到的字符串，以确定如何排序。**即使数组中的每一项都是数值，sort 方法比较的也是字符串**。[Code]()     
2. sort 方法可以接受一个比较函数作为参数，以便指定哪个值位于哪个值的前面。比较函数接收两个参数，如果**第一个参数应该位于第二个之前则返回一个负数**，如果两个参数相等则返回 0，如果第一个参数应该位于第二个参数之后则返回一个正数。  
3. sort 和 reserse 方法返回值是经过排序之后的数组。  
### 操作方法  
1. `concat()`方法可以基于当前数组中的所有项创建一个新数组。具体来说，这个方法会先**创建当前数组一个副本**，然后将接受到的参数添加到这个副本的末尾，最后返回新构建的数组。在没有给该方法传递参数的情况下，它只是复制当前数组并返回副本。如果传递给该方法的是一个或多个数组，则该方法会将这些数组中的每一项都添加到结果数组中。如果传递的值不是数组，这些之就会被简单地添加到数组的末尾。  
2. `slice()`能够基于当前数组中的一个或多个项创建一个新数组。该方法可以接受一个或两个参数，即要返回的起始和结束位置。在只有一个参数的情况下，该方法返回该参数指定位置开始到当前数组末尾的所有项。如果有两个参数，该方法返回起始位置和结束位置之间的项--**但不包括结束位置的项，该方法不会影响原始数组**。
PS：如果该方法的参数中有一个负数，则用数组长度加上该数来确定相应的位置。如果结束位置小于起始位置，则返回空数组。  
3. `splice()`最强大的数组方法，有很多用法，最主要的是向数组中插入项：  
    - 删除：可以删除任意数量的项，只需要指定 2 个参数，**要删除的第一项**和**要删除的项数**。  
    - 插入：可以向指定位置插入任意数量的项，只需要提供 3 个参数，**起始位置**、**0**（要删除的项数）和**要插入的项**，如果要插入多项，可以再传入第四、第五，以致任意多个项。  
    - 替换：可以向指定位置插入任意数量的项，且同时删除任意数量的项，只需要指定 3 个参数，**起始位置**、**要删除的项数**和**要插入的任意数量的项**，插入的项数不必与删除的项数相等。  
PS：该方法始终都会返回一个数组，该数组中包含从原始数组中删除的项（如果没有删除任何项，则返回一个空数组）。   
### 位置方法  
1. `indexOf()`从数组的开头位置开始向后查找。
2. `lastindexOf()` 从数组的末尾开始向前查找。  

PS：以上两个方法都接受两个参数：要查找的项和（可选的）表示查找起点位置的索引，都返回要查找的项在数组中的位置，或者在没有找的的情况下返回 -1。**在比较第一个参数与数组中的每一项时，会使用`全等操作符`，也就是所，要求查找的项必须严格相等（如同===）**。  
支持的浏览器包括 IE9+。  
### 迭代方法  
ECMAScript5 为数组定义了 5 个迭代方法。每个方法都接收两个参数：要在每一项上运行的函数和（可选的）运行函数的作用域对象--影响 this 的值。传入这些方法中的函数会接收三个参数值：数组项的值、该项在数组中的位置和数组对象本身。**根据使用的方法不同，这个函数运行后的返回值可能会也可能不会影响访问的返回值**。  
1. `every()`对数组中的每一项运行给定函数，**如果该函数对每一项都返回 true，则返回 true**。  
2. `filter()`对数组中的每一项运行给定函数，返回该函数会**返回 true 的项组成的数组**。  
3. `forEach()`对数组中的每一项运行给定函数，这个方法**没有返回值**。  
4. `map()`对数组中的每一项运行给定函数，**返回每次函数调用的结果组成的数组**。  
5. `some()`对数组中的每一项运行给定函数，如果**该函数对任意项返回 true，则返回 true**。  

PS：以上方法都不会修改数组中包含的值，**只有forEach不用有返回语句，其余的四个方法需要有返回语句**。  
**支持的浏览器IE9+**。

### 缩小方法        
ECMAScript5 提供了两个**缩小**数组的方法：`reduce()`和`reduceRight()`,这两个方法都会迭代数组的所有项，然后构建一个最终的返回值。其中，reduce方法从数组的第一项开始，逐个遍历到最后。而reduceRight方法则从数组的最后一项开始，向前遍历到第一项。  
这两个方法都接收两个参数：一个在每一项上调用的函数和（可选的）作为**缩小基础的初始值**。传给它们的函数接收 4 个参数：前一个值、当前值、项的索引和数组对象。**这个函数返回的任何值都会作为第一个参数自动传给下一项**。**第一次迭代发生在数组的第二项上，因此第一个参数是数组的第一项，第二个参数就是数组的第二项**。  
reduce还是reduceRight，主要取决于要从哪头开始遍历数组，除此之外，它们完全相同。  
[Code]()  
支持的浏览器 IE9+。  







