## Function 类型  
在 ECMAScript 中**函数实际上是对象**，每个函数都是 Function 类型的实例，而且都与其他引用类型一样具有**属性和方法**。由于函数是对象，因此**函数名实际上也是指向函数对象的指针，不会与某个函数绑定。函数通常是使用函数声明语法定义的**。  
函数创建：  
1. `function sum(num1, num2){
       return num1 + num2;
    }`  
2. `var sum = function(num1, num2){
       return num1 + num2;
    }`  
3. `// Function构造函数可以接收任意数量的参数，但最后一个参数始终被看做是函数体`       
   `var sum = new Function("num1", "num2", "return num1 + num2");`  

### 没有重载  
将函数名想象为指针，有助于理解为什么 ECMAScript 中没有函数重载的概念。函数表达式的方式实际上函数只涉及到函数名。  
### 函数声明与函数表达式  
函数声明和函数表达式区别：**解析器在向执行环境中加载数据时**，对函数声明和函数表达式并非一视同仁，解析器会率先读取函数声明，并使其**在执行任何代码之前可用（可以访问）**；至于**函数表达式，则必须等到解析器执行到他所在的代码行**，才会真正被解释执行。  
PS：在代码求值时，JavaScript **引擎**在第一遍**会声明函数**并将它们放到**源代码树的顶部**。所以，即使声明函数的代码在调用它的代码后面，JavaScript 引擎也能把函数声明提升到顶部。  
除了什么时候可以通过访问函数这点区别之外，函数声明与函数表达式的语法其实是等价的。  
### 作为值的函数  
ECMAScript 中函数名本身就是变量，所以函数也可以作为值来使用，可做如下应用：  
1. 可以像传递参数一样把一个函数传递给另一个函数。  
2. 可以将一个函数作为另一个函数的结果返回。 
应用场景一：根据某个属性对数组进行排序[Code]()   
PS：要访问函数的指针而不执行函数，必须去掉函数名后面的那对括号。  
### 函数内部属性  
在函数内部，包含两个特殊的对象：  
1. arguments：
    - 是一个类数组对象，包含着传入函数中所有的参数。  
    - 存在一个名叫 callee 的属性，该属性是一个指针，指向拥有这个 arguments 对象的函数，解决了递归中函数调用自己名字的问题。    
2. this 其行为与 Java 等语言的 this 大致类似，换句话说，this **引用的是函数据以执行的环境对象**--或者说也可以说是 this 值（当在网页的全局作用域中调用函数时 this 对象引用的就是 window）。  
3. caller 这个属性中保存着**调用**当前函数的函数的引用，如果是在全局作用域中调用当前函数，它的值为 null。  
### 函数属性和方法  
ECMAScript 中的函数是对象，因此每个函数也有属性和方法，每个函数都包含两个属性：length 和 prototype。  
1. length，表示函数希望接收的命名参数的个数。  
2. prototype 保存**所有实例方法**的真正所在，**prototype属性是不可枚举的，因此使用 for-in 无法实现**。  
3. apply 特性的作用域中调用函数，实际上等于设置函数体内 this 对象的值，接收两个参数，一个是**运行函数的作用域**，另一个是**参数数组（可以是Array实例，也可以是arguments对象）**  
4. call  特性的作用域中调用函数，实际上等于设置函数体内 this 对象的值，区别于上边方法，第一个参数一样，第二个参数必须逐个列举出来。  
PS：appay 和 call 传递参数并非正真的用武之地，真正强大的地方是能够扩充函数赖以运行的作用域，对象不需要与方法有任何耦合关系（TODO多态）。  
5. bind 会创建一个函数的实例，其 this 值会被绑定到传给 bind 函数的值。   
6. toString 和 toLocalString 方法始终返回函数的代码。  


